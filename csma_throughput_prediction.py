# -*- coding: utf-8 -*-
"""Untitled47.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H5RPSWdwEVDAKE-D9DGzPJCooOngqTjR
"""

import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
import matplotlib.pyplot as plt

# Transmission probabilities
transmission_prob = [0.2, 0.3, 0.5, 0.3]

# Adjacency matrix
G = [
    [0, 1, 0, 1],
    [1, 0, 1, 0],
    [0, 1, 0, 1],
    [1, 0, 1, 0]
]

# Define T (busy duration) and sigma (idle duration)
T = 3
sigma = 1
total_time_slots = 10000
num_nodes = len(transmission_prob)

class CSMADataset(Dataset):
    def __init__(self, transmission_prob, T, sigma, G, num_samples=1000):
        self.transmission_prob = transmission_prob
        self.T = T
        self.sigma = sigma
        self.G = G
        self.num_nodes = len(transmission_prob)
        self.num_samples = num_samples
        self.features, self.labels = self.generate_data()

    def __len__(self):
        return self.num_samples

    def __getitem__(self, idx):
        return self.features[idx], self.labels[idx]

    def check_for_collision(self, busy_nodes, node_states):
        for node in busy_nodes:
            for neighbor in range(self.num_nodes):
                if self.G[node][neighbor] == 1 and node_states[neighbor] == 1:
                    return True
        return False

    def simulate_csma(self):
        node_states = np.zeros(self.num_nodes, dtype=int)  # 0: idle, 1: busy
        time_slot_counter = np.zeros(self.num_nodes, dtype=int)
        success_counter = np.zeros(self.num_nodes, dtype=int)  # Counter for successful transmissions

        for t in range(total_time_slots):
            # Update states based on counters
            for i in range(self.num_nodes):
                if time_slot_counter[i] > 0:
                    time_slot_counter[i] -= 1
                    if time_slot_counter[i] == 0:
                        node_states[i] = 0

            # Check if all nodes are idle
            if np.all(node_states == 0):
                # Determine new states based on transmission probabilities
                for i in range(self.num_nodes):
                    if np.random.rand() < self.transmission_prob[i]:
                        node_states[i] = 1
                        time_slot_counter[i] = self.T

                # Check for collisions among neighbors
                busy_nodes = np.where(node_states == 1)[0]
                if self.check_for_collision(busy_nodes, node_states):
                    for i in busy_nodes:
                        time_slot_counter[i] = self.T
                elif len(busy_nodes) > 0:
                    for busy_node in busy_nodes:
                        node_states[busy_node] = 1
                        time_slot_counter[busy_node] = self.T
                        success_counter[busy_node] += 1  # Increment success counter

        return success_counter * T / total_time_slots

    def generate_data(self):
        features = []
        labels = []
        for _ in range(self.num_samples):
            feature = np.random.rand(self.num_nodes)
            self.transmission_prob = feature.tolist()  # Update transmission_prob for simulation
            label = self.simulate_csma()
            features.append(feature)
            labels.append(label)
        features = np.array(features)
        labels = np.array(labels)
        return torch.tensor(features, dtype=torch.float32), torch.tensor(labels, dtype=torch.float32)

# Define the neural network model
class CSMARegressor(nn.Module):
    def __init__(self, input_size):
        super(CSMARegressor, self).__init__()
        self.fc1 = nn.Linear(input_size, 64)
        self.fc2 = nn.Linear(64, 32)
        self.fc3 = nn.Linear(32, input_size)

    def forward(self, x):
        x = torch.relu(self.fc1(x))
        x = torch.relu(self.fc2(x))
        x = self.fc3(x)
        return x

# Initialize the dataset and dataloader
dataset = CSMADataset(transmission_prob, T, sigma, G)
dataloader = DataLoader(dataset, batch_size=16, shuffle=True)

# Initialize the model, loss function, and optimizer
model = CSMARegressor(len(transmission_prob))
criterion = nn.MSELoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# Initialize list to store the loss values
loss_values = []

# Training loop
num_epochs = 1000
for epoch in range(num_epochs):
    for features, labels in dataloader:
        optimizer.zero_grad()
        outputs = model(features)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()

    if (epoch + 1) % 100 == 0:
        print(f'Epoch [{epoch + 1}/{num_epochs}], Loss: {loss.item():.4f}')
    loss_values.append(loss.item())

# Plot the training loss
plt.figure()
plt.plot(range(1, num_epochs + 1), loss_values)
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.title('Training Loss over Epochs')
plt.grid(True)
plt.show()

# Collect predictions and actual values for plotting
predicted_throughput = []
actual_throughput = []

with torch.no_grad():
    for features, labels in dataloader:
        outputs = model(features)
        predicted_throughput.extend(outputs.numpy())
        actual_throughput.extend(labels.numpy())

# Convert lists to numpy arrays for plotting
predicted_throughput = np.array(predicted_throughput)
actual_throughput = np.array(actual_throughput)

# Plot predicted vs actual saturation throughput
plt.figure()
plt.scatter(actual_throughput, predicted_throughput)
plt.xlabel('Actual Saturation Throughput')
plt.ylabel('Predicted Saturation Throughput')
plt.title('Predicted vs Actual Saturation Throughput')
plt.grid(True)
plt.show()